function str = decode(signal, fs, duration, f, chirp_f1, chirp_f2)
%% 定义变量
% 片段长度
window = fs * duration;
% 数据包各部分长度
header_len = 8;
package_whole_len = 256;
payload_len = package_whole_len - header_len;

% QAM参数
M = 4;
standard_piece_cnt = 3;
standard_part_length = standard_piece_cnt * M * window;
standard_signal = encode_standard(fs, duration, f);

%% 拆分数据包 
[start_pos, end_pos] = find_package(signal);
start_pos
end_pos
package_cnt = length(start_pos);

for i = 1 : package_cnt
    % 截取数据包     
    package_signal = signal(start_pos : end_pos);
    % 寻找目标信号
    first_chirp_pos = find_chirp(signal(1:80000), fs, duration, chirp_f1, chirp_f2)
    temp_signal = signal(first_chirp_pos : first_chirp_pos + 2 * window + standard_part_length);
    delaytime = finddelay(standard_signal, temp_signal)
    temp_signal = signal(first_chirp_pos + window: first_chirp_pos + window + standard_part_length);
    [standard_i, standard_q] = decode_standard(temp_signal, fs, duration, f);
    % standard_i
    % standard_q
    figure(2)
    scatter(standard_i,standard_q);
    
    payload_signal = signal(first_chirp_pos + window + standard_part_length: first_chirp_pos + window + standard_part_length + 150000);
    package = QAM_demod(payload_signal, standard_i, standard_q, fs, duration, f)';
    header = package(1 : 8);
    header
    data_code_length = binarytouint8(header);
    data_code_length
    data_code = package(9 : data_code_length + 8);
end
% 
% length(data_code)
% str = bin2string(data_code);












% cut_size = 0;
% plot(standard_signal)
% package_cnt = 0;
% while chirp_pos + window < whole_signal_length
%     chirp_pos
%     package_cnt = package_cnt + 1;
% 
%     start_pos = chirp_pos + window;
% 
%     % 除去chirp
%     signal = signal(start_pos - cut_size - 1: length(signal));
%     cut_size = start_pos - 1;
%     
%     % 解出前导码和包头 
%     temp_preamble_code = QAM_demod(signal(1 : front_piece_cnt * window), fs, duration, f)'
%     
%     % 包头信息
% %     preamble_code = temp_preamble_code(1 : pre_len)
%     header_code = temp_preamble_code(pre_len + 1 : pre_len + header_len);
%     
%     % 计算数据包长度
%     data_length = hamming_decode(header_code);
%     real_length = binarytouint8(data_length)
% 
%     whole_length = pre_len + header_len + real_length;
%     length_in_signal = (whole_length / 4) * window;
% 
%     % QAM 解调信号
%     payload = QAM_demod(signal(front_piece_cnt * window + 1 : length_in_signal), fs, duration, f)';
%     
%     % 拼接
%     massage = [massage, payload];
%     
%     % 截取signal
%     signal = signal(whole_length / 4 * window : length(signal));
%     
%     if length(signal) < window + pre_len + header_len
%         break;
%     end
% 
%     % 在剩下部分中找chirp起始位置
%     chirp_pos = cut_size + find_chirp(signal, fs, duration, chirp_f1, chirp_f2);
% 
% end
% 
% % 输出
% disp('Demodulation succeed.');
% disp([num2str(package_cnt), ' package intotal.']);
% 
% %% 解码为字符串
% str = bin2string(massage);
end